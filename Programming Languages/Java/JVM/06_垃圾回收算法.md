# JAVA垃圾回收算法

## 复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。GC时将存活的对象移动到未使用的一般内存中，然后将已经满了的那一半内存空间整个**一次性清理掉**。

每次对整个一半的内存进行回收，效率比较高。但是内存只能利用到50%。

适用于对象存活率低的场景，如：新生代。当对象存活率较高时就要进行较多的复制操作，效率将会变低（所以老年代一般不适合这种算法）。

## 标记-清除算法

分为**标记**和**清除**两个阶段。

存在问题：

1、效率问题：两个阶段的效率都不高。

2、空间问题：标记清除算法不需要进行对象的移动，只对垃圾对象进行处理。因此清除之后会产生大量不连续的内存碎片。

## 标记-整理（压缩）算法

类似标记-清除算法，多了一步整理的操作。类似磁盘整理，以提高内存利用率。

与标记-清除算法最显著的区别是：标记-清除算法不会进行对象的移动，并且仅对不存活的对象进行处理；而标记-整理算法会将所有的存活对象移动到一起，并清除不存活的对象，因此不会产生内存碎片。

## 三色标记算法

CMS、G1 使用三色标记。

黑色：对象已经被标记过，且该对象的属性也全部被标记过了。（存活的对象）
灰色：对象以及被标记过，但该对象的数据没有全被标记完。（GC需要从该对象中去寻找垃圾）
白色：对象没有被标记。（垃圾对象）

存在问题：

1、浮动垃圾：若一个对象已经被标记为黑色或者灰色对象，在垃圾回收之前该对象突然变成垃圾对象（没有引用指向它）。但是这个对象已经被标记为黑色或者灰色，无法再根据GC ROOT找到这个对象，所以成了浮动垃圾。  
2、漏标：对象被标记为黑色之后，突然增加了一个白色对象（垃圾）的引用。但是黑色对象不会再次扫描，所以此时该白色对象并不会被重新标记，所以还是会被当成垃圾回收掉，此时程序就会出现异常。

解决漏标问题：

CMS：**通过增量更新（Increment Update）**

在一个未被标记的对象（白色对象）被重新引用后，**引用该白色对象的对象**要变成灰色。在下次二次标记时，让GC线程继续标记这个灰色对象的属性所引用的对象。

但是就算时这样，其仍然是存在漏标的问题：

## 分代收集算法
