# Cobra 使用指南

[官方指南](https://github.com/spf13/cobra/blob/master/user_guide.md)

虽然允许根据自己需求调整结构，但通常基于 Cobra 的应用程序将遵循以下组织结构：

    ▾ appName/
    ▾ cmd/
        add.go
        your.go
        commands.go
        here.go
      main.go

在一个Cobra应用中，通常 `main.go` 文件是非常空的。 它有一个目的：初始化 Cobra。

    package main

    import (
        "{pathToYourApp}/cmd"
    )

    func main() {
        cmd.Execute()
    }

## 使用Cobra生成器

Cobra 提供了自己的程序，可以创建您的应用程序并添加您想要的任何命令。这是将 Cobra 整合到应用中的最简单方法。

[参考](https://github.com/spf13/cobra/blob/master/cobra/README.md)更多信息。

## 使用Cobra库

为了手动实现Cobra，需要创建一个空的`main.go`文件和一个`rootCmd`文件。可以选择性地提供额外的合适的命令。

### 创建 rootCmd

Cobra不需要任何特殊的构造器。可以简单地创建命令。

理想情况下，app/cmd/root.go 中代码如下：

    var rootCmd = &cobra.Command{
        Use:   "hugo",
        Short: "Hugo is a very fast static site generator",
        Long: `A Fast and Flexible Static Site Generator built with
                        love by spf13 and friends in Go.
                        Complete documentation is available at http://hugo.spf13.com`,
        Run: func(cmd *cobra.Command, args []string) {
            // Do Stuff Here
        },
    }

    func Execute() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

另外可以在`init()`函数中定义`标志`和处理配置。

例如，cmd/root.go：

    package cmd

    import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
    )

    var (
        // Used for flags.
        cfgFile     string
        userLicense string

        rootCmd = &cobra.Command{
            Use:   "cobra",
            Short: "A generator for Cobra based Applications",
            Long: `Cobra is a CLI library for Go that empowers applications.
    This application is a tool to generate the needed files
    to quickly create a Cobra application.`,
        }
    )

    // Execute executes the root command.
    func Execute() error {
        return rootCmd.Execute()
    }

    func init() {
        cobra.OnInitialize(initConfig)

        rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.cobra.yaml)")
        rootCmd.PersistentFlags().StringP("author", "a", "YOUR NAME", "author name for copyright attribution")
        rootCmd.PersistentFlags().StringVarP(&userLicense, "license", "l", "", "name of license for the project")
        rootCmd.PersistentFlags().Bool("viper", true, "use Viper for configuration")
        viper.BindPFlag("author", rootCmd.PersistentFlags().Lookup("author"))
        viper.BindPFlag("useViper", rootCmd.PersistentFlags().Lookup("viper"))
        viper.SetDefault("author", "NAME HERE <EMAIL ADDRESS>")
        viper.SetDefault("license", "apache")

        rootCmd.AddCommand(addCmd)
        rootCmd.AddCommand(initCmd)
    }

    func initConfig() {
        if cfgFile != "" {
            // Use config file from the flag.
            viper.SetConfigFile(cfgFile)
        } else {
            // Find home directory.
            home, err := os.UserHomeDir()
            cobra.CheckErr(err)

            // Search config in home directory with name ".cobra" (without extension).
            viper.AddConfigPath(home)
            viper.SetConfigType("yaml")
            viper.SetConfigName(".cobra")
        }

        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil {
            fmt.Println("Using config file:", viper.ConfigFileUsed())
        }
    }

### 创建 main.go

有了rootCmd，还需要mian函数去执行它。为清楚起见，Execute 应该在rootCmd上运行，尽管它可以在任何命令上调用。

在Cobra应用中，通常main.go文件都是很空的，只有一个目的：初始化Cobra。

    package main

    import (
        "{pathToYourApp}/cmd"
    )

    func main() {
         cmd.Execute()
    }

### 创建额外的命令

可以额外地创建命令，通常在 cmd/目录下为每个命令提供单独的文件。

比如，若想创建一个version命令，可以创建cmd/version.go文件，内容如下：

    package cmd

    import (
    "fmt"

    "github.com/spf13/cobra"
    )

    func init() {
        rootCmd.AddCommand(versionCmd)
    }

    var versionCmd = &cobra.Command{
        Use:   "version",
        Short: "Print the version number of Hugo",
        Long:  `All software has versions. This is Hugo's`,
        Run: func(cmd *cobra.Command, args []string) {
            fmt.Println("Hugo Static Site Generator v0.9 -- HEAD")
        },
    }

### 返回并处理错误

可以使用`RunE`来给使用命令的用户返回错误：

package cmd

    import (
        "fmt"

        "github.com/spf13/cobra"
    )

    func init() {
        rootCmd.AddCommand(tryCmd)
    }

    var tryCmd = &cobra.Command{
        Use:   "try",
        Short: "Try and possibly fail at something",
        RunE: func(cmd *cobra.Command, args []string) error {
            if err := someFunc(); err != nil {
                return err
            }
            return nil
        },
    }

通过`RunE`，错误就能在运行时被捕获。

### 使用标志（Flags）

标志给命令执行提供修饰符。

#### 给命令定义标志

由于标志是在不同位置定义和使用的，我们需要在外部定义一个具有正确范围的变量来分配要使用的标志。

    var Verbose bool
    var Source string

有两种不同的方式来定义标志。

#### Persistent Flags（持久标志）

标志可以是`persistent（持续）`的，这意味着该标志将可用于**分配给它的命令**以及**该命令下的每个命令**。对于全局标志，可以在根命令上分配一个标志作为持久标志。

    rootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")

#### Local Flags（本地标志）

也可以在本地分配标志，该标志仅适用于该特定命令。

    localCmd.Flags().StringVarP(&Source, "source", "s", "", "Source directory to read from")

#### 父命令上的Local Flags

默认情况下，Cobra只在目标命令上解析本地标志， 并且任何本地标志在父命令中都将被忽略。开启`Command.TraverseChildren`，Cobra将会在执行目标命令之前在每一个命令上解析本地标志。

    command := cobra.Command{
        Use: "print [OPTIONS] [COMMANDS]",
        TraverseChildren: true,
    }

#### 通过配置绑定标志（Bind Flags with Config）

可以通过[viper](https://github.com/spf13/viper)绑定标志：

    var author string

    func init() {
        rootCmd.PersistentFlags().StringVar(&author, "author", "YOUR NAME", "Author name for copyright attribution")
        viper.BindPFlag("author", rootCmd.PersistentFlags().Lookup("author"))
    }

在这个例子中，持久标志`author`和`viper`绑定了。注意：当用户未提供 `--author` 标志时，变量 `author` 将不会设置为配置中的值。

[viper文档](https://github.com/spf13/viper#working-with-flags)

#### Required flags（必要标志）

默认情况下，标志是可选的。如果希望当标志没有设置的时候报告一个错误，可以将标志标记为**必须**：

    rootCmd.Flags().StringVarP(&Region, "region", "r", "", "AWS region (required)")
    rootCmd.MarkFlagRequired("region")

或者，对于持久标志：

    rootCmd.PersistentFlags().StringVarP(&Region, "region", "r", "", "AWS region (required)")
    rootCmd.MarkPersistentFlagRequired("region")

### 位置和自定义参数
