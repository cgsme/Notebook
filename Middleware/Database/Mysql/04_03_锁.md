# 锁

每个连接都会在 MySQL 服务端产生一个线程（内部通过线程池管理线程），比如一个 select 语句进入，MySQL 首先会在查询缓存中查找是否缓存了这个 select 的结果集，如果没有则继续执行解析、优化、执行的过程；否则会之间从缓存中获取结果集。

## 1 按锁粒度划分

### 1.1 行级锁

**InnoDB的行级锁是通过给索引上的索引项加锁来实现的**。

InnoDB一定存在聚簇索引，行锁最终都会落到聚簇索引上。通过非聚簇索引查询的时候，会先锁非聚簇索引再锁聚簇索引。

如果where预计立马既有聚簇索引，又有二级索引，则会先锁聚簇索引，再锁二级索引。

行锁兼容矩阵：

- 间隙锁（Gap Lock）：只锁间隙，前开后开区间（a, b）。对索引的间隙加锁，防止其他事务插入数据。
- 记录锁（Record Lock）：只锁记录，特定几行记录。
- 临键锁（Next-Key Lock）：同时锁住记录和间隙，前开后闭区间(a, b]。
- 插入意图锁（Insert Intention Lock）：插入时使用的锁。

**注意点:**

- 对于**记录锁**，列必须是**唯一索引列或者主键列**，查询语句必须为精确匹配，如“=”，否则记录锁会退化为临键锁。
- **间隙锁**和**临键锁**基于**非唯一索引**，在唯一索引列上不存在间隙锁和临键锁。

**只有正确通过索引条件检索数据（没有索引失效的情况），InnoDB才会使用行级锁，否则InnoDB对表中的所有记录加锁，也就是将锁住整个表。**然而**锁住整个表**和**使用表锁**是两个不同意思。

### 1.2 表级锁

### 1.2.1 Intention Locks （意向锁）

> Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table

“假的表锁”

意向锁的主要目的是为了使得**行锁**和**表锁**共存，事务在申请行锁前，必须先申请表的意向锁，成功后再申请行锁。注意：申请意向锁的动作是数据库完成的，不需要开发者来申请。

意向锁分为意向读锁(IS)和意向写锁(IX)。

**意向锁协议：**在事务能够获取表中的**行上**的共享锁之前，它必须首选获取表上的IS锁或更强的锁。在事务能够获取表中的**行上**的独占锁之前，它必须首选获取表上的IX锁。

“意向锁仅表意向，是一种较弱的锁，意向锁之间兼容并行(IS、IX 之间关系兼容并行)。 X与IS\IX互斥；S与IX互斥。可以体会到，意向锁是比X\S更弱的锁，存在一种预判的意义！先获取更弱的IX\IS锁，如果获取失败就不必要再花费跟大开销获取更强的X\S锁 ... ...”

## 2 按读写划分

## 2.1 共享锁、排他锁

共享锁（s）和排他锁（x）都是**行级锁**。

**共享锁**：也称为**读锁**，允许多个连接可以同时并发的读取同一资源，互补干扰。
**排他锁**：也称为**写锁**，一个写锁会阻塞其他的写锁或者读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。

**注意：共享锁、排他锁其实是锁机制本身的策略，通过这两种策略对锁做了区分。**
